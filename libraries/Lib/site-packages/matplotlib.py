class Pyplot :
    """
    Very, very limited implementation of
                http://matplotlib.org/api/pyplot_summary.html
    """
    #  Coding notes:
    #     'x+=1' is very slow in Brython, use 'x=x+1'

    def __init__(self):
        from browser import doc
        self.canvas      = doc["plot_area"]
        self.Debug       = False
        self.clear()

    def clear(self):
        from browser import window
        self.pixelScale  = window.devicePixelRatio
        # pixelScale needed for smooth plotting on retina and similar screens
        self.canvas.width  = window.innerWidth*0.9
        self.canvas.height = window.innerHeight*0.5
        self.width         = self.canvas.width
        self.height        = self.canvas.height

        self.ctx         = self.canvas.getContext('2d')
        self.xmin          = None
        self.xmax          = None
        self.ymin          = None
        self.ymax          = None
        self.dxTick        = None
        self.dyTick        = None
        # Make sure left margin is not too small
        self.x_margin      = 85
        self.y_margin      = 0.07*self.height
        self.use_log_x     = False
        self.use_log_y     = False
        self.a_x           = 1
        self.b_x           = 0
        self.a_y           = 1
        self.b_y           = 0
        if self.Debug :
            print("Canvas Width,Height:",self.canvas.width,self.canvas.height)
            print("Offset Width,Height:",self.canvas.offsetWidth,
                        self.canvas.offsetHeight)
            print("Pixel Scale Factor:",self.pixelScale)

    def axis_bounds(self,xmin, xmax, num_ticks=10):
        # Based on http://stackoverflow.com/questions/4947682
        from math import floor, ceil, log

        def nice_number(value, rounded=False):
            exponent = floor(log(value, 10))
            fraction = value/10**exponent
            if rounded :
                if   fraction < 1.5 : nice_fraction =  1.
                elif fraction < 3.  : nice_fraction =  2.
                elif fraction < 7.  : nice_fraction =  5.
                else                : nice_fraction  = 10.
            else:
                if   fraction <= 1  : nice_fraction =  1.
                elif fraction <= 2  : nice_fraction =  2.
                elif fraction <= 5  : nice_fraction =  5.
                else                : nice_fraction = 10.
            return nice_fraction * 10**exponent
        raw_width = xmax - xmin
        if raw_width == 0:
            axis_tick, axis_start, axis_end  = 1, xmin -1, xmin +1, 3
        else:
            nice_range = nice_number(raw_width)
            axis_tick  = nice_number(nice_range / (num_ticks -1),
                                        rounded=True)
            axis_start = floor(xmin / axis_tick) * axis_tick
            axis_end   = ceil(xmax / axis_tick) * axis_tick
            N_ticks    = int((axis_end-axis_start)/axis_tick)
        return axis_start, axis_end, axis_tick, N_ticks

    def map_xy(self,x, y):
        return (self.a_x*x+self.b_x, self.a_y*y+self.b_y)

    def draw_marker(self,x,y, marker=None, markeredgewidth = 1,
                                        markersize = 2,
                                        color = "blue") :
        # See http://www.w3schools.com/graphics/canvas_reference.asp
        from math import pi
        if marker == None or marker == "None" : return
        x_canvas,y_canvas = self.map_xy(x, y)
        self.ctx.beginPath()
        self.ctx.strokeStyle = color
        self.ctx.fillStyle = color
        self.ctx.lineWidth = markeredgewidth
        if marker == ',' :
            # Single pixel
            self.ctx.fillRect(x_canvas,y_canvas,1,1)
        elif marker == 's' :
            # Square centered on x,y
            self.ctx.fillRect(x_canvas-markersize,y_canvas-markersize,
                                                2*markersize,2*markersize)
        elif marker == '_' :
            x1,y1 = x_canvas-markersize, y_canvas,
            x2,y2 = x_canvas+markersize, y_canvas
            self.ctx.fillRect(  x_canvas-markersize,
                                y_canvas-markeredgewidth,
                                2*markersize, 2*markeredgewidth)
        else :
            # Default is a filled circle
            self.ctx.arc(x_canvas,y_canvas,markersize,0,2*pi)
        self.ctx.fill()          # Fill elements defined since last stroke
        self.ctx.stroke()        # Draw elements defined since last stroke

    def draw_line(self,x1, y1, x2, y2, linewidth = 1, color = "black",
                                        dashes=[]) :
        x1,y1 = self.map_xy(x1, y1)
        x2,y2 = self.map_xy(x2, y2)
        self.ctx.strokeStyle = color
        self.ctx.setLineDash(dashes)
        self.ctx.lineWidth = linewidth
        self.ctx.beginPath()
        self.ctx.moveTo(x1,y1)
        if linewidth > 0 :
            self.ctx.lineTo(x2,y2)
        else :
            # If linewidth = 0, just move without drawing
            self.ctx.moveTo(x1,y1)
        self.ctx.stroke()

    def draw_text(self,string,x, y, font='normal 15px Courier') :

        # Scale font for retina screens
        fontArgs = font.split()
        fontSize = int(fontArgs[-2].split('px')[0])
        newSize = fontSize
        scaledFont=''
        for i in range(len(fontArgs[0:-2])) :
            scaledFont = scaledFont + fontArgs[i]+' '
        scaledFont = scaledFont + str(newSize)+'px '+fontArgs[-1]
        self.ctx.font = scaledFont

        x_canvas,y_canvas = self.map_xy(x, y)
        self.ctx.fillStyle = 'black'
        self.ctx.strokeStyle = 'black'
        self.ctx.lineWidth = 1
        self.ctx.fillText(string, x_canvas,y_canvas)

    def draw_rect(self,x1, y1, x2, y2, linewidth = 1, color = "black",
                                        dashes=[]) :
        x1,y1 = self.map_xy(x1, y1)
        x2,y2 = self.map_xy(x2, y2)
        self.ctx.beginPath()
        self.ctx.strokeStyle = color
        self.ctx.setLineDash(dashes)
        self.ctx.lineWidth = linewidth
        self.ctx.moveTo(x1,y1)
        self.ctx.lineTo(x2,y2)
        self.ctx.stroke()

    def get_canvas_scales(self,axis='xy') :
        # x_canvas = a_x*x+b_x, y_canvas = a_y*y+b_y
        if axis =='x' or axis =='xy' :
            self.a_x = (self.width-2*self.x_margin)/(self.xmax-self.xmin)
            self.b_x = self.x_margin-self.a_x*self.xmin
        if axis =='y' or axis =='xy' :
            self.a_y = (self.height-2*self.y_margin)/(self.ymin-self.ymax)
            self.b_y = self.y_margin-self.a_y*self.ymax

    def xlim(self,xMin,xMax) :
        self.xmin, self.xmax    = xMin, xMax
        self.get_canvas_scales(axis='x')
    def ylim(self,yMin,yMax) :
        self.ymin, self.ymax    = yMin,yMax
        self.get_canvas_scales(axis='y')
    def xscale(self,axis_type) :
        if axis_type == 'log' :
            self.use_log_x   = True
        else :
            self.use_log_x   = False
    def yscale(self,axis_type) :
        if axis_type == 'log' :
            self.use_log_y   = True
        else :
            self.use_log_y   = False

    def axis(self, color='black', linewidth = 2):
        N_ticks=10
        xMin,xMax,Dx, Nx_ticks = self.axis_bounds(self.xmin, self.xmax,
                                                    num_ticks=N_ticks)
        yMin,yMax,Dy, Ny_ticks = self.axis_bounds(self.ymin, self.ymax,
                                                    num_ticks=N_ticks)
        #Draw x axis
        self.draw_line(xMin,yMin, xMax,yMin,
                            linewidth = linewidth, color = color)
        # Draw x tick marks & labels
        tick_length = 10.
        dx = tick_length/abs(self.a_x)
        dy = tick_length/abs(self.a_y)
        # Label position tweaks (this is rough, better to tie to font size)
        dx_label = dx/2.4
        dy_label = dy/3
        for i in range(Nx_ticks+1) :
            x_tick = xMin+i*Dx
            self.draw_line( x_tick, yMin, x_tick, yMin+dy,
                            linewidth = linewidth, color = color)
            if self.use_log_x :
                x_label = '{:<9g}'.format(10**x_tick)
            else:
                x_label = '{:<9g}'.format(x_tick)
            self.draw_text(x_label, x_tick-dx_label,
                                    yMin+0.7*self.y_margin/self.a_y)

        #Draw y axis
        self.draw_line(xMin,yMin, xMin,yMax,
                           linewidth = linewidth, color = color)
        # Draw y tick marks
        for i in range(Ny_ticks+1) :
            y_tick = yMin+i*Dy
            self.draw_line( xMin,    y_tick, xMin+dx, y_tick,
                            linewidth = linewidth, color = color)
            if self.use_log_x :
                y_label = '{:>9g}'.format(10**y_tick)
            else:
                y_label = '{:>9g}'.format(y_tick)
            self.draw_text(y_label,
                            -self.b_x/self.a_x,
                            y_tick-dy_label)

    def plot(self,x,y,  color           = 'black',
                        drawstyle       = 'default',
                        dashes          = [],
                        linewidth       = 1,
                        linestyle       = '-',
                        marker          = None,
                        markeredgewidth = 0,
                        markersize      = 4):

        from math import log10
        if self.use_log_x :
            j=0
            for i in range(len(x)) :
                if x[i]>0 :
                    x[j] = log10(x[i])
                    y[j] = y[i]
                    j = j+1
            x = x[:j]
            y = y[:j]
        # Transform y values if vertical (y) axis has log scale
        if self.use_log_y :
            j=0
            for i in range(len(y)) :
                if y[i]>0 :
                    x[j] = x[i]
                    y[j] = log10(y[i])
                    j = j+1
            x = x[:j]
            y = y[:j]

        # Draw axes if they have not previously been drawn
        self.xmin,self.xmax,self.dxTick,N = self.axis_bounds(
                                                min(x), max(x), num_ticks=10)
        self.ymin,self.ymax,self.dyTick,N = self.axis_bounds(
                                                min(y), max(y), num_ticks=10)
        self.get_canvas_scales()
        self.axis()

        # Dashes override linestyle
        if dashes == [] :
            if linestyle == 'None' :
                linewidth = 0
            elif linestyle == '--' :
                dashes = [5,5]
            elif linestyle == ':' :
                dashes = [1,2]
            elif linestyle == '-.' :
                dashes = [5,5,1,5]
        # Plot data
        if drawstyle == 'steps-post' :
            # Create steps for step plot
            x_out, y_out = [x[0],x[0]],[0,y[0]]
            for i in range(1,len(x)) :
                x_out.append(x[i]), y_out.append(y[i-1])
                x_out.append(x[i]), y_out.append(y[i])
            x,y = x_out, y_out
        for i in range(len(x)-1) :
            x1, y1 = x[i],y[i]
            x2, y2 = x[i+1], y[i+1]
            self.draw_line(x1, y1, x2, y2, linewidth=linewidth,
                                dashes=dashes, color=color)
            self.draw_marker(x1,y1, color=color, marker=marker,
                                    markeredgewidth=markeredgewidth,
                                    markersize=markersize)
        self.draw_marker(x2,y2, color=color, marker=marker,
                                    markeredgewidth=markeredgewidth,
                                    markersize=markersize)

    def errorbar(self,x,y, xerr=None, yerr=None,
                        color           = 'black',
                        drawstyle       = 'default',
                        dashes          = [],
                        linewidth       = 1,
                        linestyle       = '-',
                        marker          = None,
                        markeredgewidth = 0,
                        markersize      = 4) :
        # x error bars
        if xerr != None :
            x_lo, x_hi = [],[]
            try :
                # Asymmetric individual error bars for each point
                for i in range(len(x[0])) :
                    x_lo.append(x[i] - xerr[0][i])
                    x_hi.append(x[i] + xerr[1][i])
            except :
                try :
                    # Symmetric individual error bars for each point
                    for i in range(len(x)) :
                        x_lo.append(x[i] - xerr[i])
                        x_hi.append(x[i] + xerr[i])
                except :
                    # Symmetric constant error bars for each point
                    for i in range(len(x)) :
                        x_lo.append(x[i] - xerr)
                        x_hi.append(x[i] + xerr)
            # Draw error bar line
            self.plot([x_lo,x_hi], [y,y], linewidth = 1, color = "black")
            # Draw high cap on error bar
            self.plot([x_hi,x_hi], [y-markersize, y+markersize], 
                                linewidth = 1, color = "black")
            # Draw low cap on error bar
            self.plot([x_lo,x_lo], [y-markersize, y+markersize], 
                                linewidth = 1, color = "black")
        # y error bars
        if yerr != None :
            y_lo, y_hi = [],[]
            try :
                # Asymmetric individual error bars for each point
                for i in range(len(y[0])) :
                    y_lo.append(y[i] - yerr[0][i])
                    y_hi.append(y[i] + yerr[1][i])
            except :
                try :
                    # Symmetric individual error bars for each point
                    for i in range(len(y)) :
                        y_lo.append(y[i] - yerr[i])
                        y_hi.append(y[i] + yerr[i])
                except :
                    # Symmetric constant error bars for each point
                    for i in range(len(y)) :
                        y_lo.append(y[i] - yerr)
                        y_hi.append(y[i] + yerr)
           # Draw error bar line
            self.plot([x,x], [y_lo,y_hi], linewidth = 1, color = "black")
            # Draw high cap on error bar
            self.plot([x-markersize,x+markersize], [y_hi, y_hi], 
                                linewidth = 1, color = "black")
            # Draw low cap on error bar
            self.plot([x-markersize,x+markersize], [y_lo, y_lo], 
                                linewidth = 1, color = "black")

                
        # Plot central values now so they are on top of the error bars
        self.plot(x,y,
                        color=color,
                        drawstyle       = drawstyle,
                        dashes          = dashes,
                        linewidth       = linewidth,
                        linestyle       = linestyle,
                        marker          = marker,
                        markeredgewidth = markeredgewidth,
                        markersize      = markersize)                

    def bar(self, left,height, width =0.8,
                        xerr=None, yerr=None,
                        color           = 'black',
                        drawstyle       = 'default',
                        dashes          = [],
                        linewidth       = 1,
                        linestyle       = '-',
                        marker          = None,
                        markeredgewidth = 0,
                        markersize      = 4) :
        # Draw error bar line
        for i in range(len(left)) :
            self.draw_line(left[i], 0, left[i], height[i],
                            linewidth = 1, color = "black")

    def clf(self) :
        # Reset plotting so axes will be drawn anew
        self.ctx.clearRect(0, 0, self.canvas.width, self.canvas.height);
        self.__init__()

    def show(self) :
        # A null function for compatibility with offline scripts
        return


pyplot=Pyplot()