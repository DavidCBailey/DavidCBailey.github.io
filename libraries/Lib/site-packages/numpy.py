## Pseudo numpy
#     Only a tiny subset is implemented
#  Coding notes:
#     'x+=1' is very slow in Brython, use 'x=x+1'
#     'x**2' is slower than 'x*x'
#     '/' is slower than '*'

def add (a,x) :
    # a+x, where a is a list and x may be a list or a scalar
    try :
        return [a[i]+x[i] for i in range(len(a))]
    except :
        return [a[i]+x for i in range(len(a))]

def divide (a,x) :
    # Divide list a by x, where x may be a list or a scalar
    try :
        return [a[i]/x[i] for i in range(len(a))]
    except :
        return [a[i]/x for i in range(len(a))]

def histogram(data,bins=10,range=None, weights=None) :
    if range == None :
        x_min,x_max = min(data)-1e-11,max(data)+1e-11
    else :
        x_min,x_max = range[0],range[1]

    # Deal with numpy's unfortunate choice of 'range' as histogram argument
    import sys
    if sys.version_info[0] < 3:
        import __builtin__ as builtins
    else:
        import builtins
    range=builtins.range
    
    unweighted = weights==None       

    try :
        # If bins is the number of bins
        bin_size = (x_max-x_min)/bins
        inv_bin_size = 1./bin_size   # Useful for speed in loop
        bin_edges = []
        contents  = bins*[0]
        # Calculate bin_edges
        for i in range(bins+1) :
            bin_edges.append(x_min+i*bin_size)
        # Fill histogram, taking advantage of equal bin sizes for speed
        for i in range(len(data)) :
            if data[i]>=x_min and data[i]<x_max :
                j = int((data[i]-x_min)*inv_bin_size)
                if unweighted :
                    contents[j]=contents[j]+1
                else :
                    contents[j]=contents[j]+weights[i]
                        
    except :
        # If not a scalar, bins should be a sequence of bin edges
        bin_edges = bins        
        nbins     = len(bins)
        contents  = nbins*[0]
        # Fill histogram
        for i in range(len(data)) :
            for j in range(1,nbins) :
                if data[i] < bin_edges[j] :
                    if unweighted :
                        contents[j]=contents[j]+1
                    else :
                        contents[j]=contents[j]+weights[i]
                    break

    return contents, bin_edges

def mean(list):
    # Return average value of list of numbers
    return float(sum(list))/len(list)

def multiply (a,b) :
    # Multiply list a by b, where a or b or both can be lists
    try :
        # Two lists
        return [a[i]*b[i] for i in range(len(a))]
    except :
        try :
            # a is a list but b is not
            return [a[i]*b for i in range(len(a))]
        except :
            try :
                # b is a list, but a is not
                return [a*b[i] for i in range(len(b))]
            except :
                return a*b

def power (a,b) :
    # list a to the power x, where x may be a list or a scalar
    try :
        # Two lists
        return [a[i]**b[i] for i in range(len(a))]
    except :
        try :
            # a is a list but b is not
            return [a[i]**b for i in range(len(a))]
        except :
            try :
                # b is a list, but a is not
                return [a**b[i] for i in range(len(b))]
            except :
                return a**b

def std(list):
    from math import sqrt
    # Return standard deviation of list of numbers
    mean_value = mean(list)
    variance   = 0
    # Note that Brython slows down dealing with very large floats, so
    #   subtracting mean value within loop is safer, although it is often
    #   somewhat slower than simply summing value**2 and doing the
    #   subraction outside the loop.
    for value in list:
        variance = variance+(value-mean_value)*(value-mean_value)
    return sqrt(variance/len(list))
    
def subtract (a,x) :
    # Subtract x from a, where x may be a list or a scalar
    try :
        return [a[i]-x[i] for i in range(len(a))]
    except :
        return [a[i]-x for i in range(len(a))]
